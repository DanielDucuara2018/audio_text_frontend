import React, { useState, useEffect, useCallback, useRef } from 'react';
import { connect, ConnectedProps } from 'react-redux';
import {
  setCurrentJob,
  addJobToHistory,
  updateJobStatus,
  setSettings,
  clearCurrentJob,
  setError,
  clearError,
  removeJobFromHistory,
  viewJobResult,
} from '../actions/appActions';
import Api from '../Api';
import { getWebSocketUrl } from '../Api';
import axios, { AxiosError } from 'axios';
import './AudioTranscription.css';
import { TranscriptionJob, WhisperModel, JobStatus, AppSettings } from '../types';

// Job status constants matching backend
const JOB_STATUS: Record<string, JobStatus> = {
  PENDING: 'pending' as JobStatus,
  PROCESSING: 'processing' as JobStatus, 
  COMPLETED: 'completed' as JobStatus,
  FAILED: 'failed' as JobStatus
};

// Updated model descriptions with faster-whisper performance
const WHISPER_MODELS: Array<{ value: WhisperModel; label: string }> = [
  { value: 'tiny', label: 'Tiny' },
  { value: 'base', label: 'Base' },
  { value: 'small', label: 'Small' },
  { value: 'medium', label: 'Medium' },
  // { value: 'large-v3', label: 'Large V3' },
  // { value: 'turbo', label: 'Turbo' }
];

type PropsFromRedux = ConnectedProps<typeof connector>;

const AudioTranscription = ({
  currentJob,
  jobHistory,
  settings,
  error,
  setCurrentJob,
  addJobToHistory,
  updateJobStatus,
  setSettings,
  clearCurrentJob,
  setError,
  clearError,
  removeJobFromHistory,
  viewJobResult
}: PropsFromRedux) => {
  // Local state for UI
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploadProgress, setUploadProgress] = useState<number>(0);
  const [presignedUrl, setPresignedUrl] = useState<string | null>(null);
  const [audioPreviewUrl, setAudioPreviewUrl] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isRecovering, setIsRecovering] = useState<boolean>(false);
  const [showDonation, setShowDonation] = useState<boolean>(false);
  const [showEmailModal, setShowEmailModal] = useState<boolean>(false);
  const [emailAddress, setEmailAddress] = useState<string>('');
  const [isSendingEmail, setIsSendingEmail] = useState<boolean>(false);
  
  // Refs for cleanup
  const websocketRef = useRef<WebSocket | null>(null);
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const isRecoveringRef = useRef<boolean>(false); // Prevent double recovery in Strict Mode

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      console.log('Component unmounting - closing WebSocket');
      if (websocketRef.current) {
        try {
          websocketRef.current.close();
          websocketRef.current = null;
        } catch (error) {
          console.error('Error closing WebSocket on unmount:', error);
        }
      }
      if (audioPreviewUrl) {
        URL.revokeObjectURL(audioPreviewUrl);
      }
    };
  }, [audioPreviewUrl]);

  // Warn user before leaving page during processing
  useEffect(() => {
    const isProcessing = currentJob && [JOB_STATUS.PENDING, JOB_STATUS.PROCESSING].includes(currentJob?.status);
    
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (isProcessing) {
        e.preventDefault();
        e.returnValue = 'Transcription in progress. Are you sure you want to leave?';
        return e.returnValue;
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [currentJob]);

  // Recover job on page load (check if there's a job in progress)
  useEffect(() => {
    const recoverJob = async () => {

      if (!currentJob) {
        console.log('No job to recover (currentJob is null)');
        return;
      }

      if (![JOB_STATUS.PENDING, JOB_STATUS.PROCESSING].includes(currentJob.status)) {
        console.log(`Job ${currentJob.id} is ${currentJob.status}, no recovery needed`);
        return;
      }

      // Prevent double execution in React Strict Mode
      if (isRecoveringRef.current) {
        console.log('Recovery already in progress, skipping duplicate call');
        return;
      }

      console.log(`Recovering job ${currentJob.id} (status: ${currentJob.status})...`);
      isRecoveringRef.current = true; // Mark recovery as in progress
      setIsRecovering(true);

      try {
        // Poll backend for current status
        const response = await Api.get(`/job/status/${currentJob.id}`);
        const jobData = response.data;

        if (jobData.status === JOB_STATUS.COMPLETED) {
          // Job finished while user was away
          console.log('Job completed during page refresh');
          const blob = new Blob([jobData.result_text], { type: 'text/plain' });
          const downloadUrl = URL.createObjectURL(blob);

          updateJobStatus({
            ...currentJob,
            status: JOB_STATUS.COMPLETED,
            result: jobData.result_text,
            processingTime: jobData.processing_time_seconds,
            language: jobData.language,
            languageProbability: jobData.language_probability,
            downloadUrl,
            downloadFilename: `${currentJob.filename}_transcription.txt`,
          });
        } else if (jobData.status === JOB_STATUS.FAILED) {
          // Job failed while user was away
          console.log('Job failed during page refresh');
          updateJobStatus({
            ...currentJob,
            status: JOB_STATUS.FAILED,
            error: jobData.error_message || 'Transcription failed',
          });
        } else {
          // Still processing - reconnect WebSocket
          console.log('Job still processing, reconnecting WebSocket...');
          connectWebSocket(currentJob.id);
        }
      } catch (error) {
        console.error('Failed to recover job status:', error);
        // Try WebSocket anyway as fallback
        connectWebSocket(currentJob.id);
      } 
    };

    recoverJob();

    // Cleanup function to reset recovery flag if component unmounts during recovery
    return () => {
      if (isRecoveringRef.current) {
        console.log('Cleanup: Resetting recovery flag');
        isRecoveringRef.current = false;
      }
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run once on mount

  // Handle file selection
  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Validate file type
    const allowedTypes = ['audio/mp3', 'audio/wav', 'audio/m4a', 'audio/flac', 'audio/ogg', 'audio/aac', 'audio/mp4', 'video/mp4', 'audio/opus'];
    if (!allowedTypes.includes(file.type) && !file.name.match(/\.(mp3|wav|m4a|flac|ogg|aac|mp4|opus)$/i)) {
      setError('Please select a valid audio file (MP3, WAV, M4A, FLAC, OGG, AAC, MP4, OPUS)');
      return;
    }

    // Validate file size (10MB limit based on backend config)
    const maxSize = 10 * 1024 * 1024; // 10MB in bytes
    if (file.size > maxSize) {
      setError('File size must be less than 10MB');
      return;
    }

    clearError();
    setSelectedFile(file);
    
    // Create preview URL
    const previewUrl = URL.createObjectURL(file);
    setAudioPreviewUrl(previewUrl);

    try {
      // Get presigned URL for upload
      const response = await Api.get('/audio/get_presigned_url', {
        params: {
          filename: file.name,
          content_type: file.type,
          file_size: file.size
        }
      });
      
      setPresignedUrl(response.data.url);
    } catch (error) {
      const axiosError = error as AxiosError<{ detail?: string }>;
      setError(axiosError.response?.data?.detail || 'Failed to prepare file upload');
    }
  };

  // Upload file to S3
  const uploadFile = async () => {
    if (!selectedFile || !presignedUrl) return null;

    try {
      setUploadProgress(0);
      
      // Upload directly to S3 using presigned URL
      await axios.put(presignedUrl, selectedFile, {
        headers: {
          'Content-Type': selectedFile.type,
        },
        onUploadProgress: (progressEvent: any) => {
          const progress = Math.round((progressEvent.loaded * 100) / (progressEvent.total || progressEvent.loaded));
          setUploadProgress(progress);
        }
      });

      return presignedUrl;
    } catch (error) {
      const axiosError = error as AxiosError<{ detail?: string }>;
      throw new Error(axiosError.response?.data?.detail || 'Failed to upload file');
    }
  };

  // Start transcription process
  const startTranscription = async () => {
    if (!selectedFile || !presignedUrl) {
      setError('Please select a file first');
      return;
    }

    if (isSubmitting) {
      return; // Prevent multiple submissions
    }

    try {
      setIsSubmitting(true);
      clearError();
      
      // Upload file first
      const fileUrl = await uploadFile();
      if (!fileUrl) return;

      // Create transcription job
      const response = await Api.post('/job/transcribe', {
        filename: selectedFile.name,
        url: fileUrl,
        mode: settings.whisperModel
      });

      const job = {
        id: response.data.id,
        filename: selectedFile.name,
        status: JOB_STATUS.PENDING,
        whisperModel: settings.whisperModel,
        createdAt: new Date().toISOString(),
        fileSize: selectedFile.size,
        fileType: selectedFile.type
      };

      setCurrentJob(job);
      addJobToHistory(job);
      
      // Start WebSocket connection for real-time updates
      connectWebSocket(job.id);
      
    } catch (error) {
      const axiosError = error as AxiosError<{ detail?: string }>;
      setError(axiosError.response?.data?.detail || 'Failed to start transcription');
      setIsSubmitting(false);
    }
  };

  // WebSocket connection for real-time updates
  const connectWebSocket = useCallback((jobId: string) => {
    // Close existing connection if any
    if (websocketRef.current) {
      console.log('Closing existing WebSocket connection...');
      websocketRef.current.close();
      websocketRef.current = null;
    }

    // Small delay to ensure previous connection is fully closed
    setTimeout(() => {
      const wsUrl = `${getWebSocketUrl('/job/ws/')}${jobId}`;
      console.log('Connecting to WebSocket:', wsUrl);
      
      try {
        const ws = new WebSocket(wsUrl);
        websocketRef.current = ws;

        ws.onopen = () => {
          console.log('WebSocket connected for job:', jobId);
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          
          // Handle ping messages with pong response
          if (data.type === 'ping') {
            try {
              ws.send(JSON.stringify({ type: 'pong', timestamp: new Date().toISOString() }));
            } catch (error) {
              console.error('Failed to send pong:', error);
            }
            return;
          }
          
          // Handle job updates
          if (data.type === 'job_update') {
            // Create updated job using jobId instead of stale currentJob
            const baseJobUpdate = {
              id: jobId,
              status: data.status,
              result: data.result,
              error: data.message,
              processingTime: data.processing_time,
              updatedAt: new Date().toISOString(),
              // New faster-whisper fields
              language: data.language,
              languageProbability: data.language_probability
            };

            if (data.status === JOB_STATUS.COMPLETED) {            
                // Create downloadable blob
                const blob = new Blob([data.result], { type: 'text/plain' });
                const downloadUrl = URL.createObjectURL(blob);

                const completedJob = {
                    ...baseJobUpdate,
                    downloadUrl,
                    downloadFilename: `${selectedFile?.name || 'transcription'}_transcription.txt`
                };

                updateJobStatus(completedJob);
                ws.close();
            } else if (data.status === JOB_STATUS.FAILED) {
                updateJobStatus(baseJobUpdate);
                setError(data.message || 'Transcription failed');
                ws.close();
            } else {
                // For PENDING or PROCESSING status
                updateJobStatus(baseJobUpdate);
            }
          }
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          // Don't show error on initial connection attempts during recovery
          if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            setError('Connection error. Please try again.');
          }
        };

        ws.onclose = (event) => {
          console.log('WebSocket connection closed', event.code, event.reason);
          // Clean up reference
          if (websocketRef.current === ws) {
            websocketRef.current = null;
          }
        };
      } catch (error) {
        console.error('Failed to create WebSocket:', error);
        setError('Failed to establish connection. Please try again.');
      }
    }, 100); // 100ms delay to ensure clean connection
  }, [updateJobStatus, selectedFile, setError]);

  // Cancel current job
  const cancelJob = () => {
    if (websocketRef.current) {
      websocketRef.current.close();
    }
    clearCurrentJob();
    resetForm();
  };

  // Reset form to initial state
  const resetForm = () => {
    setSelectedFile(null);
    setUploadProgress(0);
    setPresignedUrl(null);
    setIsSubmitting(false);
    if (audioPreviewUrl) {
      URL.revokeObjectURL(audioPreviewUrl);
      setAudioPreviewUrl('');
    }
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
    clearError();
  };

  // Start new transcription
  const startNew = () => {
    cancelJob();
    resetForm();
  };

  // Update settings
  const handleSettingsChange = (key: keyof AppSettings, value: any) => {
    setSettings({
      ...settings,
      [key]: value
    });
  };

  // Download transcription
  const downloadTranscription = async () => {
    if (!currentJob?.result) return;

    const filename = currentJob.downloadFilename || `${currentJob.filename}_transcription.txt`;
    const text = currentJob.result;

    // Check if we're on a mobile device
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Try Web Share API first (mobile devices)
    if (isMobile && navigator.share && navigator.canShare) {
      try {
        // Create a file to share
        const file = new File([text], filename, { type: 'text/plain' });
        
        if (navigator.canShare({ files: [file] })) {
          await navigator.share({
            files: [file],
            title: 'Audio Transcription',
            text: 'Transcription from VoiceIA'
          });
          return; // Successfully shared
        }
      } catch (error) {
        console.log('Share failed or cancelled:', error);
        // Fall through to traditional download
      }
    }

    // Traditional download method (desktop and fallback for mobile)
    try {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      
      // For iOS Safari - open in new tab if download fails
      if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
        link.target = '_blank';
      }
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Clean up blob URL after a delay
      setTimeout(() => URL.revokeObjectURL(url), 100);
    } catch (error) {
      console.error('Download failed:', error);
      setError('Failed to download. Please try the email option instead.');
    }
  };

  // Send transcription by email
  const sendTranscriptionByEmail = async () => {
    if (!emailAddress || !currentJob?.result) {
      setError('Please enter a valid email address');
      return;
    }

    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(emailAddress)) {
      setError('Please enter a valid email address');
      return;
    }

    try {
      setIsSendingEmail(true);
      clearError();

      await Api.post('/audio/send_transcription_email', {
        id: currentJob.id,
        email: emailAddress,
      });

      alert('Transcription sent successfully to ' + emailAddress);
      setShowEmailModal(false);
      setEmailAddress('');
    } catch (error) {
      const axiosError = error as AxiosError<{ detail?: string }>;
      setError(axiosError.response?.data?.detail || 'Failed to send email. Please try again.');
    } finally {
      setIsSendingEmail(false);
    }
  };

  // Copy transcription to clipboard
  const copyToClipboard = async () => {
    if (!currentJob?.result) return;

    try {
      await navigator.clipboard.writeText(currentJob.result);
      alert('Transcription copied to clipboard!');
    } catch (error) {
      console.error('Failed to copy:', error);
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = currentJob.result;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        alert('Transcription copied to clipboard!');
      } catch (err) {
        setError('Failed to copy to clipboard');
      }
      document.body.removeChild(textarea);
    }
  };

  // Remove job from history
  const handleRemoveJob = (jobId: string) => {
    removeJobFromHistory(jobId);
  };

  // View job result
  const handleViewJob = (job: TranscriptionJob) => {
    if (job.status === JOB_STATUS.COMPLETED && job.result) {
      viewJobResult(job);
    }
  };

  const isProcessing = currentJob && [JOB_STATUS.PENDING, JOB_STATUS.PROCESSING].includes(currentJob.status);
  const isCompleted = currentJob?.status === JOB_STATUS.COMPLETED;
  const isFailed = currentJob?.status === JOB_STATUS.FAILED;

  return (
    <div className="transcription-container">
      <div className="transcription-card">
        <div className="header">
          <h1>Audio Transcription</h1>
          <p>Convert your audio files to text using AI-powered transcription</p>
        </div>

        {/* Donation Section */}
        <div className="donation-section">
          <button 
            className="donation-toggle"
            onClick={() => setShowDonation(!showDonation)}
          >
            <span className="donation-icon">üíù</span>
            <span>Support this project</span>
            <span className={`toggle-arrow ${showDonation ? 'open' : ''}`}>‚ñº</span>
          </button>
          
          {showDonation && (
            <div className="donation-content">
              <p className="donation-message">
                If you find this tool useful, consider supporting its development!
              </p>
              <div className="donation-methods">
                <div className="donation-method">
                  <h4>Bitcoin (BTC)</h4>
                  <div className="btc-donation">
                    <div className="qr-code-container">
                      <img
                        src="/btc-qr-code.png"
                        alt="Bitcoin QR Code"
                        className="qr-code"
                        onError={(e) => {
                          const target = e.target as HTMLImageElement;
                          const placeholder = target.nextElementSibling as HTMLElement;
                          target.style.display = 'none';
                          if (placeholder) placeholder.style.display = 'flex';
                        }}
                      />
                      <div className="qr-placeholder" style={{display: 'none'}}>
                        <span>QR Code</span>
                        <small>Upload to /public/btc-qr-code.png</small>
                      </div>
                    </div>
                    <div className="btc-address">
                      <code className="crypto-address" id="btc-address">
                        bc1qngl88gth8ufqjx8v9fdx2xdslcvkdnztccn5h3
                      </code>
                      <button 
                        className="copy-btn"
                        onClick={() => {
                          const addressElement = document.getElementById('btc-address');
                          const address = addressElement?.textContent || '';
                          navigator.clipboard.writeText(address);
                          alert('Bitcoin address copied!');
                        }}
                        title="Copy address"
                      >
                        üìã
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              <p className="donation-thanks">Thank you for your support! üôè</p>
            </div>
          )}
        </div>

        {error && (
          <div className="error-message">
            <span>{error}</span>
            <button onClick={clearError} className="error-close">√ó</button>
          </div>
        )}

        {/* File Upload Section */}
        {!currentJob && (
          <div className="upload-section">
            <div className="file-input-wrapper">
              <input
                ref={fileInputRef}
                type="file"
                accept="audio/*,.mp3,.wav,.m4a,.flac,.ogg,.aac,.mp4,.opus"
                onChange={handleFileSelect}
                className="file-input"
                id="audio-file"
                aria-label="Choose audio file for transcription"
                aria-describedby="file-upload-description"
              />
              <label htmlFor="audio-file" className="file-input-label">
                <svg className="upload-icon" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                </svg>
                Choose Audio File
              </label>
              <p id="file-upload-description" className="sr-only">
                Supported formats: MP3, WAV, M4A, FLAC, OGG, AAC, MP4, OPUS. Maximum file size: 100MB.
              </p>
            </div>

            {selectedFile && (
              <div className="file-preview">
                <div className="file-info">
                  <h3>{selectedFile.name}</h3>
                  <p>{(selectedFile.size / 1024 / 1024).toFixed(2)} MB ‚Ä¢ {selectedFile.type}</p>
                </div>
                
                {audioPreviewUrl && (
                  <audio 
                    controls 
                    className="audio-preview"
                    aria-label="Preview of selected audio file"
                  >
                    <source src={audioPreviewUrl} type={selectedFile.type} />
                    Your browser does not support the audio element.
                  </audio>
                )}

                <div className="settings-section">
                  <label className="setting-label" htmlFor="model-select">
                    Whisper Model:
                    <select
                      id="model-select"
                      value={settings.whisperModel}
                      onChange={(e) => handleSettingsChange('whisperModel', e.target.value)}
                      className="model-select"
                      aria-label="Select AI transcription model"
                      aria-describedby="model-description"
                    >
                      {WHISPER_MODELS.map(model => (
                        <option key={model.value} value={model.value}>
                          {model.label}
                        </option>
                      ))}
                    </select>
                  </label>
                </div>

                <p id="model-description" className="sr-only">
                  Select the AI model for transcription. Larger models are more accurate but slower.
                </p>
                <button
                  onClick={startTranscription}
                  className="transcribe-btn"
                  disabled={isSubmitting}
                  aria-label="Start audio transcription"
                  aria-describedby="transcribe-description"
                >
                  {isSubmitting ? 'Starting...' : 'Start Transcription'}
                </button>
                <span id="transcribe-description" className="sr-only">
                  Click to begin converting your audio file to text
                </span>
              </div>
            )}
          </div>
        )}

        {/* Processing Section */}
        {isProcessing && (
          <div className="processing-section">
            <div className="processing-header">
              <h3>Processing: {currentJob.filename}</h3>
              <button onClick={cancelJob} className="cancel-btn">Cancel</button>
            </div>
            
            {uploadProgress > 0 && uploadProgress < 100 && (
              <div className="progress-section">
                <p>Uploading file...</p>
                <div className="progress-bar">
                  <div 
                    className="progress-fill" 
                    style={{ width: `${uploadProgress}%` }}
                  ></div>
                </div>
                <span className="progress-text">{uploadProgress}%</span>
              </div>
            )}

            <div className="status-section" role="status" aria-live="polite" aria-atomic="true">
              <div className="status-indicator">
                <div className="spinner" aria-hidden="true"></div>
                <span className="status-text">
                  {isRecovering
                    ? 'Reconnecting...'
                    : currentJob.status === JOB_STATUS.PENDING
                      ? 'Preparing...'
                      : 'Transcribing...'}
                </span>
              </div>
              <p className="model-info">Using {currentJob.whisperModel} model</p>
            </div>
          </div>
        )}

        {/* Results Section */}
        {isCompleted && (
          <div className="results-section">
            <div className="results-header">
              <h3>Transcription Complete</h3>
              <div className="results-meta">
                <span>Model: {currentJob.whisperModel}</span>
                {currentJob.processingTime && (
                  <span>Time: {currentJob.processingTime.toFixed(1)}s</span>
                )}
                {currentJob.language && (
                  <span>Language: {currentJob.language.toUpperCase()}
                    {currentJob.languageProbability &&
                      ` (${(currentJob.languageProbability * 100).toFixed(0)}%)`
                    }
                  </span>
                )}
              </div>
            </div>

            <div className="transcription-result">
              <textarea 
                value={currentJob.result || ''} 
                readOnly 
                className="result-textarea"
                placeholder="Transcription will appear here..."
                aria-label="Transcription result"
                aria-describedby="result-description"
              />
              <span id="result-description" className="sr-only">
                Your audio has been transcribed. Use the buttons below to download, copy, or share the text.
              </span>
            </div>

            <div className="results-actions" role="group" aria-label="Transcription actions">
              <button 
                onClick={downloadTranscription} 
                className="download-btn"
                aria-label="Download transcription as text file"
              >
                üì• Download
              </button>
              <button 
                onClick={copyToClipboard} 
                className="copy-text-btn"
                aria-label="Copy transcription to clipboard"
              >
                üìã Copy Text
              </button>
              {/*<button onClick={() => setShowEmailModal(true)} className="email-btn">
                üìß Send by Email
              </button>*/}
              <button 
                onClick={startNew} 
                className="new-btn"
                aria-label="Start new transcription with different file"
              >
                Transcribe New File
              </button>
            </div>
          </div>
        )}

        {/* Email Modal */}
        {showEmailModal && (
          <div 
            className="modal-overlay" 
            onClick={() => setShowEmailModal(false)}
            role="dialog"
            aria-modal="true"
            aria-labelledby="email-modal-title"
          >
            <div className="modal-content" onClick={(e) => e.stopPropagation()}>
              <div className="modal-header">
                <h3 id="email-modal-title">Send Transcription by Email</h3>
                <button 
                  className="modal-close"
                  onClick={() => setShowEmailModal(false)}
                  aria-label="Close email modal"
                >
                  √ó
                </button>
              </div>
              <div className="modal-body">
                <p className="modal-description">
                  Enter your email address to receive the transcription
                </p>
                <input
                  type="email"
                  placeholder="your.email@example.com"
                  value={emailAddress}
                  onChange={(e) => setEmailAddress(e.target.value)}
                  className="email-input"
                  onKeyPress={(e) => {
                    if (e.key === 'Enter') {
                      sendTranscriptionByEmail();
                    }
                  }}
                />
              </div>
              <div className="modal-footer">
                <button 
                  onClick={() => setShowEmailModal(false)}
                  className="modal-cancel-btn"
                  disabled={isSendingEmail}
                >
                  Cancel
                </button>
                <button 
                  onClick={sendTranscriptionByEmail}
                  className="modal-send-btn"
                  disabled={isSendingEmail || !emailAddress}
                >
                  {isSendingEmail ? 'Sending...' : 'Send Email'}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Failed Section */}
        {isFailed && (
          <div className="failed-section">
            <h3>Transcription Failed</h3>
            <p className="error-details">{currentJob.error || 'Unknown error occurred'}</p>
            <button onClick={startNew} className="retry-btn">
              Try Again
            </button>
          </div>
        )}

        {/* Job History */}
        {jobHistory.length > 0 && !isProcessing && (
          <div className="history-section">
            <h3>Recent Jobs</h3>
            <div className="history-list">
              {jobHistory.slice(0, 10).map((job: TranscriptionJob) => (
                <div key={job.id} className="history-item">
                  <div className="history-info">
                    <span className="history-filename">{job.filename}</span>
                    <span className={`history-status status-${job.status}`}>
                      {job.status}
                    </span>
                  </div>
                  <div className="history-meta">
                    <span className="history-date">
                      {new Date(job.completedAt || job.createdAt || Date.now()).toLocaleDateString()}
                    </span>
                    <div className="history-actions">
                      {job.status === JOB_STATUS.COMPLETED && job.result && (
                        <button
                          onClick={() => handleViewJob(job)}
                          className="history-view-btn"
                          title="View result"
                        >
                          üëÅÔ∏è
                        </button>
                      )}
                      <button
                        onClick={() => handleRemoveJob(job.id)}
                        className="history-remove-btn"
                        title="Remove from history"
                      >
                        üóëÔ∏è
                      </button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

interface RootState {
  currentJob: TranscriptionJob | null;
  jobs: TranscriptionJob[];
  settings: AppSettings;
  error: string | null;
}

const mapStateToProps = (state: RootState) => ({
  currentJob: state.currentJob,
  jobHistory: state.jobs || [],
  settings: state.settings || { whisperModel: 'base' as WhisperModel },
  error: state.error
});

const mapDispatchToProps = {
  setCurrentJob,
  addJobToHistory,
  updateJobStatus,
  setSettings,
  clearCurrentJob,
  setError,
  clearError,
  removeJobFromHistory,
  viewJobResult
};

const connector = connect(mapStateToProps, mapDispatchToProps);

export default connector(AudioTranscription);