# Nginx Configuration Guide

This document explains every element in both nginx configurations used in the Audio Text Frontend project.

## Table of Contents

- [Overview](#overview)
- [nginx-dev.conf (Development Configuration)](#nginx-devconf-development-configuration)
- [nginx-prod.conf (Production Configuration)](#nginx-prodconf-production-configuration)
- [Key Differences: Dev vs Prod](#key-differences-dev-vs-prod)
- [Path Forwarding Behavior](#path-forwarding-behavior)

---

## Overview

The project uses two nginx configurations:

- **nginx-dev.conf**: For local development with HTTPS, SSL certificates, and React dev server proxying
- **nginx-prod.conf**: For production deployment serving static React build files with optimized caching

Both configurations support **WebSocket** connections for real-time communication with the backend.

---

## nginx-dev.conf (Development Configuration)

### Upstream Blocks

```nginx
upstream frontend {
    server audio-text-frontend.app:3202;
}

upstream backend {
    server audio-text-backend.app:3203;
}
```

**Purpose**: Define backend server groups that nginx can load balance or proxy to.

- **`audio-text-frontend.app:3202`**: The React development server running on port 3202
- **`audio-text-backend.app:3203`**: The FastAPI backend server running on port 3203
- **`.app` domain**: Docker Compose service names resolved via Docker's internal DNS

### HTTP to HTTPS Redirect Server

```nginx
server {
  listen 80 default_server;
  server_name localhost voiceia.techlab.local;
  return 301 https://$host$request_uri;
}
```

**Purpose**: Force all HTTP traffic to use HTTPS for security.

- **`listen 80`**: Listen on HTTP port
- **`default_server`**: Makes this the default server block for port 80
- **`server_name`**: Domains this server responds to (localhost and custom local domain)
- **`return 301`**: Permanent redirect (301) to HTTPS version of the same URL
- **`$host`**: Original hostname from the request
- **`$request_uri`**: Original URI including query parameters

### HTTPS Server Block

```nginx
server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;
  server_name localhost voiceia.techlab.local;
```

**Purpose**: Main server block handling HTTPS traffic.

- **`listen 443 ssl http2`**: Enable HTTPS on port 443 with HTTP/2 support
- **`[::]:443`**: IPv6 binding
- **`http2`**: Enables HTTP/2 protocol for better performance
  - **Benefits**: Request multiplexing, header compression, server push
  - **Use case**: Faster page loads with multiple asset requests

### SSL Configuration

```nginx
ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
ssl_dhparam /etc/ssl/certs/dhparam.pem;

ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
ssl_prefer_server_ciphers off;
```

**Purpose**: Configure SSL/TLS encryption for secure HTTPS connections.

- **`ssl_certificate`**: Path to the SSL certificate (public key)
  - Generated by `scripts/start-dev.sh` script using OpenSSL
- **`ssl_certificate_key`**: Path to the private key
  - Must be kept secure and never committed to git
- **`ssl_dhparam`**: Diffie-Hellman parameters for enhanced forward secrecy
  - 2048-bit key for strong encryption
- **`ssl_protocols`**: Only allow TLS 1.2 and 1.3 (secure versions)
  - TLS 1.0 and 1.1 are deprecated and vulnerable
- **`ssl_ciphers`**: Specific encryption algorithms to use
  - Only strong ciphers (AES-256, GCM mode, SHA-384/512)
  - ECDHE/DHE for perfect forward secrecy
- **`ssl_prefer_server_ciphers off`**: Let client choose cipher
  - Modern browsers choose secure ciphers by default

### Security Headers

```nginx
add_header X-Frame-Options "SAMEORIGIN";
add_header X-Content-Type-Options "nosniff";
add_header X-XSS-Protection "1; mode=block";
```

**Purpose**: Protect against common web vulnerabilities.

- **`X-Frame-Options: SAMEORIGIN`**: Prevents clickjacking attacks
  - Only allows embedding in iframes from same origin
  - Prevents malicious sites from embedding your app invisibly
- **`X-Content-Type-Options: nosniff`**: Prevents MIME-type sniffing
  - Forces browsers to respect Content-Type headers
  - Prevents browsers from interpreting files as different types (e.g., JS as HTML)
- **`X-XSS-Protection: 1; mode=block`**: Enables browser's XSS filter
  - Legacy header for older browsers
  - Modern browsers use CSP (Content Security Policy) instead

### Client Settings

```nginx
client_max_body_size 256M;
```

**Purpose**: Control maximum upload size.

- **256M**: Maximum allowed size for file uploads (256 megabytes)
- **Use case**: Audio file uploads to the backend API
- **Important**: Must match or exceed backend's max upload size

### Frontend Location Block

```nginx
location / {
    proxy_pass http://frontend;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
```

**Purpose**: Forward all root path requests to React development server.

- **`location /`**: Matches all requests by default (lowest priority)
- **`proxy_pass http://frontend`**: Forward to frontend upstream (React dev server on port 3202)
- **`Host`**: Preserve original hostname
  - React dev server needs this for hot module reloading (HMR)
- **`X-Real-IP`**: Client's actual IP address
  - Without this, backend only sees nginx's IP
- **`X-Forwarded-For`**: Chain of proxy IP addresses
  - Format: `client_ip, proxy1_ip, proxy2_ip`
  - Useful for logging and geolocation
- **`X-Forwarded-Proto`**: Original protocol (http/https)
  - Backend needs to know if original request was secure

### WebSocket Support

```nginx
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_cache_bypass $http_upgrade;

    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
```

**Purpose**: Enable WebSocket connections for real-time communication.

- **`proxy_http_version 1.1`**: Required for WebSocket
  - HTTP/1.0 doesn't support upgrade mechanism
- **`Upgrade: $http_upgrade`**: Signals WebSocket upgrade request
  - Client sends `Upgrade: websocket`
  - nginx forwards this to backend
- **`Connection: "upgrade"`**: Required for WebSocket handshake
  - Part of the upgrade protocol
- **`proxy_cache_bypass $http_upgrade`**: Don't cache WebSocket connections
  - Prevents caching proxies from breaking WebSockets
- **`proxy_read_timeout 86400`**: 24 hours (86400 seconds) read timeout
  - WebSocket connections are long-lived
  - Default timeout (60s) would kill the connection
- **`proxy_send_timeout 86400`**: 24 hours send timeout
  - Matches read timeout for bidirectional communication

**Use cases**:

- React development server hot module reloading (HMR)
- Real-time job status updates from backend
- Live audio transcription progress

### Backend API Location

```nginx
location /api/v1/ {
    proxy_pass http://backend/api/v1/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # WebSocket support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_cache_bypass $http_upgrade;

    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
}
```

**Purpose**: Forward API requests to backend, preserving the full path.

- **`location /api/v1/`**: Match all API requests starting with `/api/v1/`
  - Higher priority than `location /`
- **`proxy_pass http://backend/api/v1/`**: Forward to backend **with path preserved**
  - **IMPORTANT**: Trailing slashes matter!
  - **Request**: `https://localhost/api/v1/users/123`
  - **Forwarded to backend**: `http://backend:3203/api/v1/users/123`
  - Path is **preserved** and sent to backend as-is

**Path Forwarding Behavior**:

```nginx
# WITH trailing slash (path preserved):
location /api/v1/ {
    proxy_pass http://backend/api/v1/;  # ← trailing slash
}
# Request: /api/v1/users → Backend receives: /api/v1/users ✓

# WITHOUT trailing slash (path replaced):
location /api/v1/ {
    proxy_pass http://backend/api/v1;   # ← no trailing slash
}
# Request: /api/v1/users → Backend receives: /api/v1users (broken!) ✗

# Using rewrite (OLD approach - now removed):
location /api/v1/ {
    rewrite ^/api/v1(.*)$ $1 break;     # Strips /api/v1 prefix
    proxy_pass http://backend;
}
# Request: /api/v1/users → Backend receives: /users
```

**Why preserve the path?**

- Backend FastAPI routes expect `/api/v1/` prefix
- Simpler configuration (no rewrite rules needed)
- Easier to debug (path remains the same end-to-end)

**Same headers and WebSocket support**: Identical to frontend location block.

### Dedicated WebSocket Endpoint

```nginx
location /api/v1/job/ws/ {
    proxy_pass http://backend/api/v1/job/ws/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
}
```

**Purpose**: Explicit WebSocket endpoint for job status updates.

- **Why separate location block?**
  - More explicit and self-documenting
  - Easier to debug WebSocket-specific issues
  - Can have different timeouts or settings if needed
  - Higher priority match (more specific path)
- **Same configuration**: Identical WebSocket settings as `/api/v1/` location
- **Path preserved**: Full `/api/v1/job/ws/` path sent to backend

**Nginx location matching priority**:

1. `location /api/v1/job/ws/` ← Most specific, matches first
2. `location /api/v1/` ← Less specific
3. `location /` ← Least specific, fallback

---

## nginx-prod.conf (Production Configuration)

### Upstream Backend

```nginx
upstream backend {
    server audio-text-backend:3203;
}
```

**Differences from dev**:

- **No frontend upstream**: In production, nginx serves static React build files directly
  - React dev server not running in production
  - Build files are copied into nginx container at `/usr/share/nginx/html`
- **`audio-text-backend`**: Docker service name for backend container
  - No `.app` suffix (different Docker Compose setup)

### Server Block

```nginx
server {
  listen 80;
  server_name localhost voiceia.techlab.local;

  root /usr/share/nginx/html;
  index index.html;
```

**Purpose**: Serve production traffic on HTTP (SSL handled upstream by Load Balancer).

- **No SSL configuration**: In cloud deployment, SSL termination happens at:
  - Google Cloud: Load Balancer or Cloud CDN
  - AWS: Application Load Balancer or CloudFront
  - Azure: Application Gateway or Front Door
- **`root /usr/share/nginx/html`**: Directory containing React build output
  - Files copied during Docker image build
  - Contains: `index.html`, `static/js/`, `static/css/`, etc.
- **`index index.html`**: Default file to serve for directory requests

### Gzip Compression

```nginx
gzip on;
gzip_vary on;
gzip_min_length 1024;
gzip_proxied any;
gzip_comp_level 6;
gzip_types text/plain text/css text/xml text/javascript
           application/javascript application/xml+rss application/json;
```

**Purpose**: Compress responses to reduce bandwidth and improve load times.

- **`gzip on`**: Enable gzip compression
- **`gzip_vary on`**: Add `Vary: Accept-Encoding` header
  - Tells caches (CDN, browsers) that response varies based on encoding support
  - Prevents serving compressed content to clients that don't support it
- **`gzip_min_length 1024`**: Only compress files larger than 1KB
  - Smaller files have overhead that exceeds compression benefit
  - Compression adds CPU cost
- **`gzip_proxied any`**: Compress responses from proxied requests (API calls)
- **`gzip_comp_level 6`**: Compression level (1-9)
  - **1**: Fastest, least compression
  - **9**: Slowest, most compression
  - **6**: Good balance between speed and compression ratio
- **`gzip_types`**: MIME types to compress
  - JavaScript files (`.js`)
  - CSS stylesheets (`.css`)
  - JSON responses from API
  - **Note**: `text/html` is always compressed (implicit)

**Compression ratios**:

- JavaScript: ~70% reduction (e.g., 500KB → 150KB)
- CSS: ~75% reduction
- JSON: ~80% reduction

### Security Headers

```nginx
add_header X-Frame-Options "SAMEORIGIN";
add_header X-Content-Type-Options "nosniff";
add_header X-XSS-Protection "1; mode=block";
```

**Same as dev configuration** - see development section for details.

### Static Files with Cache

```nginx
location /static/ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

**Purpose**: Aggressively cache static assets with hashed filenames.

- **`location /static/`**: Matches React build assets
  - Path structure: `/static/js/main.[hash].js`, `/static/css/main.[hash].css`
  - Hash changes when content changes (webpack/vite behavior)
- **`expires 1y`**: Cache for 1 year
  - Sets `Expires` header 1 year in future
  - Also sets `Cache-Control: max-age=31536000`
- **`Cache-Control: public, immutable`**:
  - **`public`**: Can be cached by CDNs, proxies, and browsers
  - **`immutable`**: File will **never change** at this URL
    - Safe because of filename hashing
    - Browser won't even send conditional requests (If-Modified-Since)
    - Maximum performance optimization

**Why this is safe**:

- React build process creates files like: `main.abc123def.js`
- If you change the code, hash changes: `main.xyz789uvw.js`
- Old file can be cached forever - new deployments use new URLs
- `index.html` references the new filename

### Frontend Root Location

```nginx
location / {
    try_files $uri $uri/ /index.html;

    location ~* \.html$ {
      expires 5m;
      add_header Cache-Control "public, must-revalidate";
    }
}
```

**Purpose**: Serve static files and support Single Page Application (SPA) routing.

- **`try_files $uri $uri/ /index.html`**: SPA routing fallback

  1. **Try `$uri`**: Check if exact file exists (e.g., `/favicon.ico`)
  2. **Try `$uri/`**: Check if directory exists (e.g., `/images/`)
  3. **Fallback to `/index.html`**: Let React Router handle the route

  **Examples**:

  - Request: `/users/123` → No file exists → Serve `index.html` → React Router renders `UsersPage`
  - Request: `/logo.png` → File exists → Serve file directly
  - Request: `/static/js/main.abc123.js` → Matches `/static/` location first (higher priority)

- **Nested `location ~* \.html$`**: Special handling for HTML files
  - **`~*`**: Case-insensitive regex match
  - **`\.html$`**: Files ending in `.html`
  - **`expires 5m`**: Short cache (5 minutes)
    - Allows quick updates when deploying new versions
    - Users get new `index.html` which references new asset hashes
  - **`Cache-Control: public, must-revalidate`**:
    - **`public`**: Can be cached by everyone
    - **`must-revalidate`**: Must check with server before using stale cache
    - After 5 minutes, browser sends `If-Modified-Since` request

**Why different caching for HTML vs assets?**

- **Assets** (`/static/`): Hashed filenames, cache forever (immutable)
- **HTML** (`index.html`): Entry point, needs to be fresh to reference new assets

### Backend API Proxy

```nginx
location /api/v1/ {
    proxy_pass http://backend/api/v1/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # WebSocket support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_cache_bypass $http_upgrade;

    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
}
```

**Same as dev configuration** with path preserved - see development section for details.

**Key point**: Full `/api/v1/` path is forwarded to backend.

### WebSocket Specific Endpoint

```nginx
location /api/v1/job/ws/ {
    proxy_pass http://backend/api/v1/job/ws/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
}
```

**Same as dev configuration** with path preserved - see development section for details.

---

## Key Differences: Dev vs Prod

| Feature               | Dev (nginx-dev.conf)                                     | Prod (nginx-prod.conf)                                 |
| --------------------- | -------------------------------------------------------- | ------------------------------------------------------ |
| **SSL/HTTPS**         | Self-signed SSL certificate, HTTPS redirect from port 80 | No SSL (handled by cloud Load Balancer/CDN)            |
| **Frontend Serving**  | Proxies to React dev server (port 3202)                  | Serves static build files from `/usr/share/nginx/html` |
| **Ports**             | 80 → 443 redirect, HTTPS on 443                          | Only HTTP on port 80                                   |
| **Caching**           | No caching (development needs fresh content)             | Aggressive caching: 1 year for assets, 5 min for HTML  |
| **Gzip Compression**  | Not configured (dev server handles it)                   | Enabled with level 6 compression                       |
| **HTTP/2**            | Enabled for HTTPS performance                            | Not configured (Load Balancer handles it)              |
| **Use Case**          | Local development with hot reloading                     | Production container deployment in cloud               |
| **WebSocket Support** | ✓ Yes (React HMR + backend)                              | ✓ Yes (backend only)                                   |
| **Path Forwarding**   | Full path preserved (`/api/v1/` → `/api/v1/`)            | Full path preserved (`/api/v1/` → `/api/v1/`)          |

---

## Path Forwarding Behavior

### Current Implementation (Path Preserved)

Both configurations now **preserve** the full path when forwarding to backend:

```nginx
location /api/v1/ {
    proxy_pass http://backend/api/v1/;  # ← Trailing slash preserves path
}
```

**Request flow**:

```
Client → nginx → Backend
/api/v1/users/123 → /api/v1/users/123 (path unchanged)
```

**Why this approach?**
✅ **Simpler**: No rewrite rules needed  
✅ **Predictable**: Path remains the same end-to-end  
✅ **Easier to debug**: What you see in browser is what backend receives  
✅ **Matches FastAPI routes**: Backend expects `/api/v1/` prefix

### Previous Implementation (Path Stripped)

The old configuration used `rewrite` to strip the `/api/v1` prefix:

```nginx
location /api/v1/ {
    rewrite ^/api/v1(.*)$ $1 break;  # ← Strip prefix
    proxy_pass http://backend;
}
```

**Request flow**:

```
Client → nginx → Backend
/api/v1/users/123 → /users/123 (prefix removed)
```

**When to use this approach?**

- Backend doesn't use `/api/v1/` prefix in routes
- Backend is at root path (`/users/123` instead of `/api/v1/users/123`)
- Multiple versions routed to different backends (`/api/v1/` → backend-v1, `/api/v2/` → backend-v2)

### Trailing Slash Rules

**Critical**: Trailing slashes change behavior!

```nginx
# Rule 1: Both have trailing slash → Path preserved
location /api/v1/ {
    proxy_pass http://backend/api/v1/;
}
# /api/v1/users → http://backend/api/v1/users ✓

# Rule 2: Location has slash, proxy_pass doesn't → Path replaced (broken!)
location /api/v1/ {
    proxy_pass http://backend/api/v1;  # ← No trailing slash
}
# /api/v1/users → http://backend/api/v1users ✗ (concatenated!)

# Rule 3: Neither has slash → Path replaced
location /api/v1 {
    proxy_pass http://backend/api/v1;
}
# /api/v1/users → http://backend/api/v1/users ✓ (but less common pattern)

# Rule 4: Location without slash, proxy_pass with slash → Path stripped
location /api/v1 {
    proxy_pass http://backend/;
}
# /api/v1/users → http://backend/users (prefix removed)
```

**Best practice**: Keep trailing slashes consistent on both sides!

### Testing Path Forwarding

**Test with curl**:

```bash
# Test that backend receives correct path
curl -v https://localhost/api/v1/health

# Check backend logs to see received path
docker-compose logs backend | grep "GET /api/v1/health"
```

**Backend FastAPI route examples**:

```python
# Backend expects /api/v1/ prefix
@app.get("/api/v1/users/{user_id}")
async def get_user(user_id: int):
    return {"id": user_id}

# Client requests: https://localhost/api/v1/users/123
# nginx forwards: http://backend:3203/api/v1/users/123
# FastAPI matches: /api/v1/users/{user_id} ✓
```

---

## Additional Resources

- **Docker Layers and Caching**: See `audio_text_backend/docs/docker-layers-and-caching.md`
- **Deployment Guide**: See `audio_text_frontend/README.md`
- **SSL Certificate Generation**: Run `./scripts/start-dev.sh` script

---

**Last Updated**: October 24, 2025
